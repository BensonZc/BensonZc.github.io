<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[BensonZc'Blog]]></title>
  <subtitle><![CDATA[拥有满满的情怀和数码周边的码农]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://bensonzc.github.io/"/>
  <updated>2016-04-01T08:27:35.000Z</updated>
  <id>http://bensonzc.github.io/</id>
  
  <author>
    <name><![CDATA[BensonZc]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[如何提升Web应用的性能]]></title>
    <link href="http://bensonzc.github.io/2016/04/01/how-to-imporve-webapp-performance/"/>
    <id>http://bensonzc.github.io/2016/04/01/how-to-imporve-webapp-performance/</id>
    <published>2016-04-01T07:36:44.000Z</published>
    <updated>2016-04-01T08:27:35.000Z</updated>
    <content type="html"><![CDATA[<p>Web应用进入平稳期后，性能变得越来越重要，功能的重要性给则越来越低。产品的响应速度很大程度的决定了产品的生命。整理了下自己能力范围内的优化方案，期待后续的不断完善</p>
<h3 id="1-_u5229_u7528_u53CD_u5411_u4EE3_u7406_u670D_u52A1_u5668"><a href="#1-_u5229_u7528_u53CD_u5411_u4EE3_u7406_u670D_u52A1_u5668" class="headerlink" title="1.利用反向代理服务器"></a>1.利用反向代理服务器</h3><p>如果Web应用运行在一台服务器上，性能问题的解决方案就是硬件的升级。但是硬件是有上限的，Web应用缓慢，是因为服务器一直在不同的任务间切换：与客户端的交互，访问磁盘上的文件，执行业务代码等等。最终内存耗尽，IO等待等问题崩溃。<br><strong>增加一个反向代理服务器来分担这些任务</strong>可以有效的提升Web应用的性能。反向代理服务器设置在运行Web应该用的服务器之前，用来处理网络流量。只有这台方向代理服务器直接连接到网络上，它和应用服务器通过内部的局域网或者其他快速的内部网络进行通信。<br>有了反向代理服务器，应用服务器不必再等待客户的响应，而是以最优的速度运行。同时也增加了应用服务器的弹性，如果某台服务器过载或者宕机了，也不会造成系统瘫痪。<br>反向代理服务器也成了很多其他性能提升方法的先决条件：</p>
<ul>
<li>负载均衡—-反向代理服务器上运行一个负载均衡器，把流量平均分配给了一堆的应用服务器。在增加应用服务器的时候完全不需要修改应用程序。</li>
<li>缓存静态文件—-直接请求的文件，比如图片，js，css等代码文件，可以存放在反向代理服务器上，直接返回给客户端，使响应更快，也分担了应用服务器的负载。<br>Nginx就是专门设计做反向代理服务器的。</li>
</ul>
<h3 id="2-_u589E_u52A0_u4E00_u4E2A_u8D1F_u8F7D_u5747_u8861_u5668"><a href="#2-_u589E_u52A0_u4E00_u4E2A_u8D1F_u8F7D_u5747_u8861_u5668" class="headerlink" title="2.增加一个负载均衡器"></a>2.增加一个负载均衡器</h3><p>负载局衡器首先需要一个反向代理服务器，它接收网络流量，并把请求转交给另一个服务器。一个窍门就是让负载均衡器支持两台以上的应用服务器，利用一个选择算法在服务器间分配请求。最简单的方法就是轮询，每个新请求发送给列表中的下一台服务器。其它方法包括把请求发送给活动连接数量最少的服务器。<br>负载均衡器可以极大地改善性能，因为它们避免让一台服务器过载，而其它服务器却处于空闲的状态。它们也很容易扩展 Web 服务器的能力，增加相对便宜的服务器并确保它们物尽其用。</p>
<h3 id="3-__u7F13_u5B58_u9759_u6001_u548C_u52A8_u6001_u5185_u5BB9"><a href="#3-__u7F13_u5B58_u9759_u6001_u548C_u52A8_u6001_u5185_u5BB9" class="headerlink" title="3. 缓存静态和动态内容"></a>3. 缓存静态和动态内容</h3><p>缓存通过更快地向客户端提供内容来改善 Web 应用的性能。<br>有两种类型的缓存需要考虑：</p>
<ul>
<li>静态内容的缓存，不经常变化的文件，比如图像文件和代码文件（css，js）可以存在一个服务器上，以便在内存或磁盘上进行快速检索。</li>
<li>动态内容的缓存，很多Web应用为每个页面请求生成新的HTML，通过简单地将已经生成的HTML保存一小段时间，就可以大幅度减少需要生成页面的总数。</li>
</ul>
<h3 id="4-__u538B_u7F29_u6570_u636E"><a href="#4-__u538B_u7F29_u6570_u636E" class="headerlink" title="4. 压缩数据"></a>4. 压缩数据</h3><p>精心设计和高效的压缩标准可以大幅减少文件的大小，文本数据，THML,CSS,JavaScript的代码，压缩这些数据会大大改善Web应用性能的体验，特别是移动客户端。</p>
<h3 id="5-__u4F18_u5316SSL/TLS"><a href="#5-__u4F18_u5316SSL/TLS" class="headerlink" title="5. 优化SSL/TLS"></a>5. 优化SSL/TLS</h3><p>SSL/TLS被越来越多的网站所采用，它们却在影响网站的性能。有两个原因影响了网站的性能：</p>
<ul>
<li>每当打开一个新的连接，最初的握手都需要建立加密密钥。浏览器使用 HTTP/1.x 和服务器建立多条连接，随着服务器的增多，连接会成倍增加。</li>
<li>服务器上加密数据，客户端解密数据，这些都是持续的开销。</li>
</ul>
<p>优化SSL/TLS的机制因应用服务器而有所差别，Nginx使用OpenSSL，运行在标准硬件上，提供类似专用硬件解决方案的性能，减少了SSL/TLS加解密对CPU和时间的消耗。</p>
<h4 id="u672C_u6587_u601D_u8DEF_u6765_u81EA_u4E8Ehttp_3A//www-kuqin-com/shuoit/20151127/349186-html"><a href="#u672C_u6587_u601D_u8DEF_u6765_u81EA_u4E8Ehttp_3A//www-kuqin-com/shuoit/20151127/349186-html" class="headerlink" title="本文思路来自于http://www.kuqin.com/shuoit/20151127/349186.html"></a>本文思路来自于<a href="http://www.kuqin.com/shuoit/20151127/349186.html" target="_blank" rel="external">http://www.kuqin.com/shuoit/20151127/349186.html</a></h4>]]></content>
    <summary type="html">
    <![CDATA[<p>Web应用进入平稳期后，性能变得越来越重要，功能的重要性给则越来越低。产品的响应速度很大程度的决定了产品的生命。整理了下自己能力范围内的优化方案，期待后续的不断完善</p>
<h3 id="1-_u5229_u7528_u53CD_u5411_u4EE3_u7406_u67]]>
    </summary>
    
      <category term="性能优化" scheme="http://bensonzc.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[面试汇总整理]]></title>
    <link href="http://bensonzc.github.io/2016/04/01/java-interview-tips/"/>
    <id>http://bensonzc.github.io/2016/04/01/java-interview-tips/</id>
    <published>2016-04-01T01:33:30.000Z</published>
    <updated>2016-04-05T07:36:39.000Z</updated>
    <content type="html"><![CDATA[<p>这辈子肯定要面试很多次，就整理了下一些面试题的集合。包括Java，数据库等</p>
<h2 id="1-_Java_u7BC7"><a href="#1-_Java_u7BC7" class="headerlink" title="1. Java篇"></a>1. Java篇</h2><p><strong>1. Java的HashMap和HashTable</strong><br>两个都是Map接口的子接口。HashMap允许NULL key和NULL value，而HashTable不允许。HashTable是线程安全的，而HashMap不是。</p>
<p><strong>2. Java BlockingQuene是什么？</strong><br>Java BlockingQuene是一个并发集合util包中的一部分。BlockingQuene队列支持在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。常用于生产者-消费者模式中。多线程间信息传递尤其有用。</p>
<p><strong>3. 什么时候使用ConcurrentHashMap？</strong><br>当有大量并发更新的时候，适合使用ConcurrentHashMap。与HashTable类似。但是ConcurrentHashMap不锁定整张表来提供并发，所以ConcurrentHashMap性能更好。</p>
<p><strong>4. LinkedList和ArrayList</strong><br>ArrayList基于动态数组的数据结构，当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能；。LinkedList基于链表的数据接口，当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList了。</p>
<p><strong>5. Iterator和ListIterator区别</strong></p>
<ul>
<li>ListIterator有add()方法，可以向List添加元素，而Iterator不能。</li>
<li>ListIterator可以实现顺序向前的遍历。而Iterator只能顺序向后的遍历。</li>
<li>ListIterator可以实现对象修改（set()方法）。Iterator仅能遍历，不能修改。两者皆可删除对象。</li>
</ul>
<p><strong>6. HashMap如何同步？</strong></p>
<ul>
<li>使用Collections.synchronizedMap(…)来同步HashMap</li>
<li>使用ConcurrentHashMap。<br>优先使用ConcurrentHashMap，因为这样就不需要锁定整个对象来获得锁。</li>
</ul>
<p><strong>7. Overload和Override的区别？Overload是否可以改变返回值类型？</strong><br>Overridingg（重写）和Overloading（重载）是Java多态性的不同表现，重写是父类与子类之间的多态，重载是一个类中的多态。子类定义了某个方法与父类有相同的名称和参数。说明该方法被重写了。如果在一个类中定义了多个同名方法，它们有不同的参数个数和参数类型，则称之为重载，重载可以改变返回值类型。</p>
<p><strong>8. final，finally，finialize的区别</strong></p>
<ul>
<li>final修饰符，如果一个类被声明成final，说明它不能派生出新的子类，不能作为父类被继承。将变量或方法声明成final，可以保证它们在使用过程中不被改变。被声明成final的方法只能使用，不能Override，可以被Overload</li>
<li>finally在异常处理中的一个块，来执行任何清除释放操作。无论是否抛出异常，程序都会进入finally块。</li>
<li>finalize时候方法名，这个方法由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。内存释放清理的操作。</li>
</ul>
<p><strong>9. Java创建线程的方式？</strong></p>
<ul>
<li>继承Thread类，重写run方法，start()启动线程。</li>
<li>实现Runnable接口，实现run方法，装载入Thread中start()启动线程。</li>
<li>使用Executor来创建线程池，通过execute启动线程。</li>
</ul>
<p><strong>10. Java集合类</strong></p>
<ul>
<li>Collection:一组对象，每个对象都是它的子元素。</li>
<li>Set:不包含重复元素的Collection。</li>
<li>List:有顺序的Collection，可以包含重复元素。</li>
<li>Map:键(key)映射值(value)的对象，键不能重复。</li>
</ul>
<p><strong>11. Enumeration接口和Iterator接口区别</strong><br>Enumeration速度是Iterator的两倍，同时占用更少的内存，只提供遍历Vector和HashTable类型集合元素的功能。Iterator远比Enumeration安全，因为其他线程不能够修改正在被Iterator遍历的集合里面的对象。</p>
<h2 id="2-__u6570_u636E_u5E93_u7BC7"><a href="#2-__u6570_u636E_u5E93_u7BC7" class="headerlink" title="2. 数据库篇"></a>2. 数据库篇</h2><p><strong>1. 数据库引擎MYISAM、INNODB</strong></p>
<ul>
<li>MyISAM不支持事务处理等高级处理，而InnoDB类型支持。</li>
<li>MyISAM的表强调的是性能，执行速度比InnoDB更快。</li>
<li>MyISAM的重要缺陷是不能再表损坏后恢复数据。</li>
<li>InnoDB中不保存表的具体行数，也就是说，执行select count(<em>) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含where条件时，两种表的操作是一样的</li>
<li>MyISAM的索引和数据是分开的，并且索引是有压缩的，内存使用率就对应提高了不少。能加载更多索引，而Innodb是索引和数据是紧密捆绑的，没有使用压缩从而会造成Innodb比MyISAM体积庞大</li>
</ul>
<p><strong>2. 数据库优化</strong></p>
<ul>
<li>减少数据访问（创建并使用正确的索引，设计适当的冗余）</li>
<li>返回更少数据（数据分页，只返回需要的字段）</li>
<li>减少交互次数（批量操作）</li>
<li>减少服务器CPU开销</li>
<li>利用更多资源</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这辈子肯定要面试很多次，就整理了下一些面试题的集合。包括Java，数据库等</p>
<h2 id="1-_Java_u7BC7"><a href="#1-_Java_u7BC7" class="headerlink" title="1. Java篇"></a>1. Java]]>
    </summary>
    
      <category term="java" scheme="http://bensonzc.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PostgreSQL高并发单行更新死锁]]></title>
    <link href="http://bensonzc.github.io/2016/03/24/deadlock-in-high-concurrency-single-row-update-postgresql/"/>
    <id>http://bensonzc.github.io/2016/03/24/deadlock-in-high-concurrency-single-row-update-postgresql/</id>
    <published>2016-03-24T06:01:23.000Z</published>
    <updated>2016-03-24T09:36:58.000Z</updated>
    <content type="html"><![CDATA[<p>工作项目中由于高并发的原因，在数据库处理中加入悲观锁，乐观锁。相安无事几天后测试发出了一段错误日志：<br><img src="/2016/03/24/deadlock-in-high-concurrency-single-row-update-postgresql/dihcsrup-1.png" alt=""><br>这日志说明太明显了，<strong>死锁</strong>，吓得我赶紧翻代码仔细排查一遍，看看到底哪里可能出现死锁…..无果…被老司机同事提醒了下，发现了psql官方社区邮件列表<br><a href="http://www.postgresql.org/message-id/20140731233051.GN17765@andrew-ThinkPad-X230" target="_blank" rel="external">http://www.postgresql.org/message-id/20140731233051.GN17765@andrew-ThinkPad-X230</a></p>
<p>原来是个已知BUG，翻了下社区的新闻。几次版本的更新都有对死锁的情况进行了优化，但是不幸的是没有找到确切的更新说明解决了该问题。只能希望后续跟进吧。</p>
<h3 id="u65B0_u8FDB_u5C55"><a href="#u65B0_u8FDB_u5C55" class="headerlink" title="新进展"></a>新进展</h3><p>PostgreSQL详细的<a href="http://www.postgresql.org/docs/current/static/mvcc.html" target="_blank" rel="external">发布文档(9.5.1版本)</a>中有提到该问题<br><img src="/2016/03/24/deadlock-in-high-concurrency-single-row-update-postgresql/dihcsrup-2.png" alt=""><br>其中13.3.4. DeadLocks中说明了此类问题出现的情况。自行阅读啦，我这英语渣都看懂了。下面是搬运：<br>13.3.4. Deadlocks</p>
<p>The use of explicit locking can increase the likelihood of deadlocks, wherein two (or more) transactions each hold locks that the other wants. For example, if transaction 1 acquires an exclusive lock on table A and then tries to acquire an exclusive lock on table B, while transaction 2 has already exclusive-locked table B and now wants an exclusive lock on table A, then neither one can proceed. PostgreSQL automatically detects deadlock situations and resolves them by aborting one of the transactions involved, allowing the other(s) to complete. (Exactly which transaction will be aborted is difficult to predict and should not be relied upon.)</p>
<p>Note that deadlocks can also occur as the result of row-level locks (and thus, they can occur even if explicit locking is not used). Consider the case in which two concurrent transactions modify a table. The first transaction executes:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance + <span class="number">100.00</span> <span class="keyword">WHERE</span> acctnum = <span class="number">11111</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>This acquires a row-level lock on the row with the specified account number. Then, the second transaction executes:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance + <span class="number">100.00</span> <span class="keyword">WHERE</span> acctnum = <span class="number">22222</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance - <span class="number">100.00</span> <span class="keyword">WHERE</span> acctnum = <span class="number">11111</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>The first UPDATE statement successfully acquires a row-level lock on the specified row, so it succeeds in updating that row. However, the second UPDATE statement finds that the row it is attempting to update has already been locked, so it waits for the transaction that acquired the lock to complete. Transaction two is now waiting on transaction one to complete before it continues execution. Now, transaction one executes:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance - <span class="number">100.00</span> <span class="keyword">WHERE</span> acctnum = <span class="number">22222</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>Transaction one attempts to acquire a row-level lock on the specified row, but it cannot: transaction two already holds such a lock. So it waits for transaction two to complete. Thus, transaction one is blocked on transaction two, and transaction two is blocked on transaction one: a deadlock condition. PostgreSQL will detect this situation and abort one of the transactions.</p>
<p>The best defense against deadlocks is generally to avoid them by being certain that all applications using a database acquire locks on multiple objects in a consistent order. In the example above, if both transactions had updated the rows in the same order, no deadlock would have occurred. One should also ensure that the first lock acquired on an object in a transaction is the most restrictive mode that will be needed for that object. If it is not feasible to verify this in advance, then deadlocks can be handled on-the-fly by retrying transactions that abort due to deadlocks.</p>
<p>So long as no deadlock situation is detected, a transaction seeking either a table-level or row-level lock will wait indefinitely for conflicting locks to be released. This means it is a bad idea for applications to hold transactions open for long periods of time (e.g., while waiting for user input).</p>
<p>简单总结下：事务1中操作TableA和TableB（或者关联导致操作了多张表），事务1获取了TableA的锁，尝试去获取TableB的锁。事务2中也操作了TableA和TableB，事务2获取了TableB的锁，尝试去获取TableA的锁。从而导致了死锁。</p>
<h3 id="PostgreSQL_u6700_u7EC8_u4E5F_u6CA1_u6709_u4E2A_u5F7B_u5E95_u7684_u89E3_u51B3_u65B9_u6848_uFF0C_u53EF_u80FD_u662F_u6211_u67E5_u9605_u8D44_u6599_u4E0D_u591F_u3002_u5982_u679C_u6709_u4EBA_u6709_u65B0_u53D1_u73B0_uFF0C_u8BF7_u5E7F_u800C_u544A_u4E4B_u3002"><a href="#PostgreSQL_u6700_u7EC8_u4E5F_u6CA1_u6709_u4E2A_u5F7B_u5E95_u7684_u89E3_u51B3_u65B9_u6848_uFF0C_u53EF_u80FD_u662F_u6211_u67E5_u9605_u8D44_u6599_u4E0D_u591F_u3002_u5982_u679C_u6709_u4EBA_u6709_u65B0_u53D1_u73B0_uFF0C_u8BF7_u5E7F_u800C_u544A_u4E4B_u3002" class="headerlink" title="PostgreSQL最终也没有个彻底的解决方案，可能是我查阅资料不够。如果有人有新发现，请广而告之。"></a>PostgreSQL最终也没有个彻底的解决方案，可能是我查阅资料不够。如果有人有新发现，请广而告之。</h3>]]></content>
    <summary type="html">
    <![CDATA[<p>工作项目中由于高并发的原因，在数据库处理中加入悲观锁，乐观锁。相安无事几天后测试发出了一段错误日志：<br><img src="/2016/03/24/deadlock-in-high-concurrency-single-row-update-postgresql/dih]]>
    </summary>
    
      <category term="java" scheme="http://bensonzc.github.io/tags/java/"/>
    
      <category term="postgresql" scheme="http://bensonzc.github.io/tags/postgresql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高并发数据库锁（乐观锁，悲观锁）]]></title>
    <link href="http://bensonzc.github.io/2016/02/25/high-concurrency-db-lock/"/>
    <id>http://bensonzc.github.io/2016/02/25/high-concurrency-db-lock/</id>
    <published>2016-02-25T08:19:34.000Z</published>
    <updated>2016-02-25T10:06:19.000Z</updated>
    <content type="html"><![CDATA[<p>工作中项目碰到高并发下各种脏数据，“被迫研究”了下数据库锁。<br>从数据库层面来讲，最典型的就是<strong>悲观锁</strong>和<strong>乐观锁了</strong></p>
<h3 id="u60B2_u89C2_u9501_uFF08Pessimisttic_Locking_uFF09"><a href="#u60B2_u89C2_u9501_uFF08Pessimisttic_Locking_uFF09" class="headerlink" title="悲观锁（Pessimisttic Locking）"></a>悲观锁（Pessimisttic Locking）</h3><p>悲观锁，指的是数据在整个处理过程中（包括本系统当前的其他事务，以及来自外部系统的事务处理），将数据处于锁定的状态。悲观锁的实现，一般依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使本系统中实现了加锁，也无法保证外部系统不会修改数据）。<br><code>select * from table where column = “test” for update</code>这句sql锁定了table表中所有column为test的数据。本次事务提交之前，外界无法修改这些数据。<br>数据锁定时，其他线程或事务进行更新操作时，会等待锁释放后才能获取到数据。<strong>不加锁的查询</strong>操作不影响。</p>
<p><img src="/2016/02/25/high-concurrency-db-lock/hcdl-1.png" alt=""><br><img src="/2016/02/25/high-concurrency-db-lock/hcdl-2.png" alt=""></p>
<p>LockOptions是LockMode的简单封装，在LockMode的基础上提供了timeout（是否等待锁释放）和scope（是否锁关联数据）。<code>JDK在注释中推荐使用LockOptions加锁，本人试过用LockMode加锁，有部分锁发现没有效果。具体原因查过，未知。但是不妨碍日常使用。</code>其中LockMode.UPGRADE_NOWAIT，Oracle特定实现，NOWAITT表明如果执行该select语句的事务不能立即获得悲观锁,那么不会等待其它事务释放锁,而是立刻抛出锁定异常</p>
<p><strong>只有在查询开始之前（Hibernate生成sql之前）设定加锁，才会通过数据库的锁机制进行加锁。</strong></p>
<h3 id="u4E50_u89C2_u9501_uFF08Optimistic_Locking_uFF09"><a href="#u4E50_u89C2_u9501_uFF08Optimistic_Locking_uFF09" class="headerlink" title="乐观锁（Optimistic Locking）"></a>乐观锁（Optimistic Locking）</h3><p>悲观锁依靠数据库的锁机制实现，保证操作的独占性。但带来了数据库性能的大量开销，特别是长事务。乐观锁解决了这个问题，乐观锁基于数据版本（Version）记录机制实现。即在表中增加字段version，更新数据的时候对version加一，提交数据时，与数据库表中的version比对，如果提交的数据version大于数据库表中的version则更新成功。反之抛出异常。</p>
<p><strong>Hibernate集成了乐观锁</strong><br>加锁的表新增字段version用于数据版本控制。支持以下类型<br><img src="/2016/02/25/high-concurrency-db-lock/hcdl-3.png" alt=""><br>用@Version注解<br><img src="/2016/02/25/high-concurrency-db-lock/hcdl-4.png" alt=""><br>创建数据的时候。version会默认为0，更新数据的时候version会自动加一，若并发导致数据不同步，更新数据version小于等于数据库表version会抛出异常<br><img src="/2016/02/25/high-concurrency-db-lock/hcdl-5.png" alt=""><br>提示当前事务已被更新或删除了</p>
<h3 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h3><p>悲观锁和乐观锁都有适用的场景，悲观锁很好的保持了数据的一致性，但是如果多个线程或事务并发，可能造成无限期等待。而乐观锁解决了这个问题，同时速度快，耗费性能低，只是多查了个字段，但是如果数据库是直接对外公开的话，外部是不受控制的，这时候就会产生脏数据。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>工作中项目碰到高并发下各种脏数据，“被迫研究”了下数据库锁。<br>从数据库层面来讲，最典型的就是<strong>悲观锁</strong>和<strong>乐观锁了</strong></p>
<h3 id="u60B2_u89C2_u9501_uFF08Pessimistt]]>
    </summary>
    
      <category term="hibernate" scheme="http://bensonzc.github.io/tags/hibernate/"/>
    
      <category term="java" scheme="http://bensonzc.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hibernate.initialize()]]></title>
    <link href="http://bensonzc.github.io/2016/02/23/hibernate-initialize/"/>
    <id>http://bensonzc.github.io/2016/02/23/hibernate-initialize/</id>
    <published>2016-02-23T08:24:52.000Z</published>
    <updated>2016-02-23T08:33:28.000Z</updated>
    <content type="html"><![CDATA[<p>使用hibernate进行持久化时，有时需要动态的改变对象的加载方式。配置中lazy属性是全局控制的。这时候需要Hibernate.initialize()。</p>
<p>###lazy加载</p>
<p>当元素lazy属性为true时，load(),get(),find()加载对象时，不会马上产生select。只是产生一个Obj代理类实例。lazy为false时，则会马上执行select来加载对象。</p>
<p>只有在session没有关闭的情况下Obj.getXXX()时会执行select语句从数据库加载对象，如果没有调用Obj.getXXX()方法，而session已经关闭，Obj成游离状态。这时候再调用Obj.getXXX()方法，Hibernate会抛出<code>Could not initialize proxy - the owning Session was closeed</code>的异常。Obj代理类实例无法被初始化。想在这种情况下调用到对象。只要在session关闭前调用Hibernate.initialize(Obj obj)静态方法，初始化代理类实例。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>使用hibernate进行持久化时，有时需要动态的改变对象的加载方式。配置中lazy属性是全局控制的。这时候需要Hibernate.initialize()。</p>
<p>###lazy加载</p>
<p>当元素lazy属性为true时，load(),get(),find]]>
    </summary>
    
      <category term="hibernate" scheme="http://bensonzc.github.io/tags/hibernate/"/>
    
      <category term="java" scheme="http://bensonzc.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java线程池整理]]></title>
    <link href="http://bensonzc.github.io/2016/02/14/thread-pool-summary/"/>
    <id>http://bensonzc.github.io/2016/02/14/thread-pool-summary/</id>
    <published>2016-02-14T06:08:32.000Z</published>
    <updated>2016-02-17T02:03:17.000Z</updated>
    <content type="html"><![CDATA[<p>年假前，闲来无事。对线程池的理解不是很系统，就索性稍微整理了下。</p>
<h2 id="1-__u7EBF_u7A0B_u6C60_u4F5C_u7528"><a href="#1-__u7EBF_u7A0B_u6C60_u4F5C_u7528" class="headerlink" title="1. 线程池作用"></a>1. 线程池作用</h2><p>线程池作用就是限制系统中执行线程的数量。根据系统的环境情况，可以自动或手动设置线程数量，合理利用资源，达到最佳效果。线程池减少了创建和销毁线程的次数，每个工作线程可以被重复利用，执行多个任务。同时根据系统的承受能力，调整线程池中工作线程的数目。</p>
<h2 id="2-__u7EBF_u7A0B_u6C60_u7C7B_u89E3_u6790"><a href="#2-__u7EBF_u7A0B_u6C60_u7C7B_u89E3_u6790" class="headerlink" title="2. 线程池类解析"></a>2. 线程池类解析</h2><ul>
<li><code>ExecutorService</code> 真正的线程池接口</li>
<li><code>ScheduledExecutorService</code> 和Timer/TimerTask类似，解决那些需要任务重复执行的问题</li>
<li><code>ThreadPoolExecutor</code> ExecutorService的默认实现。</li>
<li><code>ScheduledThreadPoolExecutor</code> 继承ThreadPoolExecutor和ScheduledExecutorService接口实现，周期性任务调度的类实现。</li>
</ul>
<p>配置一个线程池比较复杂，尤其是原理不清楚的情况下。这样配出来的线程池效果可能不是最优的，因此Executors类里面提供了一些惊呆工厂，生成一些常用的线程池。</p>
<h2 id="3-__u5E38_u7528_u7684_u51E0_u4E2A_u7EBF_u7A0B_u6C60"><a href="#3-__u5E38_u7528_u7684_u51E0_u4E2A_u7EBF_u7A0B_u6C60" class="headerlink" title="3. 常用的几个线程池"></a>3. 常用的几个线程池</h2><ul>
<li><code>newSingleThreadExecutor</code>:创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果线程出现异常结束，就会创建个新线程来代替。此线程池保证了所有任务按任务提交顺序执行。</li>
<li><code>newFixedThreadPool</code>:创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程数达到线程池最大线程数。线程池的大小一旦叨叨最大值就会保持不变。</li>
<li><code>newCachedThreadPool</code>:创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，会回收部分空闲线程，当任务数增加时，线程池又会智能的添加新线程来处理任务。线程池大小依赖于JVM能够创建的最大线程大小。</li>
<li><code>newScheduleddThreadPool</code>:创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<h2 id="4-_ThreadPoolExecutor_u8BE6_u89E3"><a href="#4-_ThreadPoolExecutor_u8BE6_u89E3" class="headerlink" title="4. ThreadPoolExecutor详解"></a>4. ThreadPoolExecutor详解</h2><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a><code>ThreadPoolExecutor</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                          <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                          <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ThreadPoolExecutor构造函数，简单解释下几个参数的意义<br><code>corePoolSize</code> - 池中保存的线程数<br><code>maximumPoolSize</code> - 池中最大线程数<br><code>keepAliveTime</code> - 线程数大于<code>corePoolSize</code>时，终止多余的空闲线程的最大时间<br><code>unit</code> - <code>keeyAliveTime</code>参数的时间单位<br><code>workQuene</code> - 保持任务的队列，仅保持由execute提交的Runnable任务<br><code>threadFactory</code> - 创建新线程时使用的工厂<br><code>handler</code> - 由于超出线程范围和队列容量而使执行被阻塞时锁使用的处理程序</p>
<h3 id="u5E38_u7528_u7684_u7EBF_u7A0B_u6C60_u6784_u9020_u5DE5_u5382"><a href="#u5E38_u7528_u7684_u7EBF_u7A0B_u6C60_u6784_u9020_u5DE5_u5382" class="headerlink" title="常用的线程池构造工厂"></a>常用的线程池构造工厂</h3><p>jdk中有这么一段注释<br><img src="/2016/02/14/thread-pool-summary/tps-1.png" alt=""><br>所以简单介绍下JDK推荐的构造线程池的方法</p>
<ol>
<li><p>newFixedThreadPool()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个corePoolSize和maximumPoolSize的大小一样，且不使用keep alive和LinkedBlockingQueue&lt;Runnable&gt;的线程池。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>newSingleThreadExecutor()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和newFixedThreadPool()类似，corePoolSize和maximumPoolSize的值都为1的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService   </span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,   </span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,   </span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>newCachedThreadPool()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建一个maximumPoolSize为Integer.MAX_VALUE，任务队列为SynchronousQueue的线程池。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,   </span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,   </span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>PS: 所有的BlockingQueue都可用于传输和保持提交的任务。（SynchronousQueue将任务直接提交给线程而不保持任务，如果不存在可用线程，则任务加入队列会失败，此队列可以避免在处理可能具有内部依赖性的请求集时出现锁。所以通常要求<code>maximumPoolSize</code>为无界来避免新任务提交到线程失败。LinkedBlockingQueue在线程数达到<code>corePoolSize</code>时，任务在队列中等待。创建的线程数不会超过<code>corePoolSize</code>，因此<code>maximumPoolSize</code>值就无效。当任务之间互相独立，互不影响适用无界队列）这个队列与线程池进行交互：</p>
<ul>
<li>如果运行的线程少于<code>corePoolSize</code>，则线程池始终会创建新线程执行任务，而不会进入队列。    </li>
<li>如果运行的线程等于或大于<code>corePoolSize</code>且小于<code>maximumPoolSize</code>，线程池会请求加入队列，而不是创建新线程。</li>
<li>如果运行线程大于<code>maximumPoolSize</code>，这种情况下，任务会被拒绝。</li>
</ul>
<h2 id="u5B9E_u4F8B"><a href="#u5B9E_u4F8B" class="headerlink" title="实例"></a>实例</h2><p>简单的按自己的理解封装了下线程池，详情看<a href="https://github.com/BensonZc/ThreadPoolDemo" target="_blank" rel="external">Demo</a>。欢迎批评指导！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>年假前，闲来无事。对线程池的理解不是很系统，就索性稍微整理了下。</p>
<h2 id="1-__u7EBF_u7A0B_u6C60_u4F5C_u7528"><a href="#1-__u7EBF_u7A0B_u6C60_u4F5C_u7528" class="heade]]>
    </summary>
    
      <category term="java" scheme="http://bensonzc.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015总结]]></title>
    <link href="http://bensonzc.github.io/2016/02/06/2015-summarize/"/>
    <id>http://bensonzc.github.io/2016/02/06/2015-summarize/</id>
    <published>2016-02-06T01:36:52.000Z</published>
    <updated>2016-02-14T06:40:29.000Z</updated>
    <content type="html"><![CDATA[<p>今天还要上班的朋友们，让我看到你们的双手…..<br>按照惯例，今天上半天班。早上肯定没心思干活了。闲来无事就给2015做个总结？</p>
<p>2015年干了不少事，除了钱，其他方面收获颇丰。最大的收获是一个人的快活变成了两个人的生活——-结婚了。和老婆从大二在一起到毕业2年左右结婚，也算功德圆满。虽然没有小情侣那样的如胶似漆，但是生活本该平淡恬静。偶尔想起大学到毕业到工作到结婚，其中的每件事现在回想起来都会把自己逗乐。不得不承认，学生时代的爱情是最真实的。没有社会物质的介入，只看脸……</p>
<p>为了婚礼能在年底如期进行，老家的房子装修紧锣密鼓的。本想大展拳脚，最后不了了之。跟父母辈的审美鸿沟实在逾越不过去。不过也算切身的体验了一下装修，也算入了个门。后面为了工作方便，和老婆的小屋装修过程中尽量亲力亲为，拿个纸笔就开始干设计。虽然最后总有些不尽如人意的地方，但是整体大方向还是把握住了。算在装修领域正式入门了，跟同龄的同学同事聊起来，也算半个老司机了，忽悠起来不在话下。也算自成一派，跑各种建材厂挑选各种材料，研究各种家用电器的适用场景。勉强能帮到一些同学朋友。欢迎一起探讨。</p>
<p>结婚免不了蜜月，因为穷，只能国内游。最后选了台湾，老婆全权负责旅行安排和房间机票订购。先是直飞高雄，入住有吾客栈（是一个从失望，满意，惊喜，到不舍的民宿）当天晚上就直奔瑞丰夜市，我一直觉得旅游就是个吃。一晚上都是烤炸的小吃加古早味红茶。第二天租个小电动车，晃悠在西子湾和旗津岛。晚上到市中心体验了下台湾的自助。第三天拼了个的士到垦丁，本人城市就靠海。所以到垦丁对看海没多大兴趣，但是骑租来的摩托然后被海风吹得噼里啪啦得感觉还是不错的，顺带赞下后壁湖的海鲜，真的是鲜且便宜。折合20RMB的一盘生鱼片，就问你怕不怕？垦丁呆了一天，第三天就高铁到了台北，进城了。陪老婆逛的是纪念馆啊，博物馆啊。台湾给我留下的印象真的是舒服，人民整体素质的确比较高。和老婆约定下次有机会再来。写博文的今天得知台湾6.7级地震？！高雄好像尤其惨重。从台湾旅游回来后，由于本人也是闽南地区。一直跟老婆戏称高雄是我的故乡，只能心里默默祈祷祝安好！灾难退散！</p>
<p>旅游回来后，就是各种败家，给自己小屋添置各种东西。购买各个部件，尝试了下装机。部了家庭千兆网，搞了家庭NAS。然后就没钱了。后面还想败一堆情怀模型手办。</p>
<p>随意记录了下一年里留下深刻印象的几件事，文笔太差，其他大大小小的事就不记了，心里想着的是—–怎么还不通知提早下班？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天还要上班的朋友们，让我看到你们的双手…..<br>按照惯例，今天上半天班。早上肯定没心思干活了。闲来无事就给2015做个总结？</p>
<p>2015年干了不少事，除了钱，其他方面收获颇丰。最大的收获是一个人的快活变成了两个人的生活——-结婚了。和老婆从大二在一起到毕业]]>
    </summary>
    
      <category term="生活" scheme="http://bensonzc.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="随记" scheme="http://bensonzc.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sonar常见问题整理]]></title>
    <link href="http://bensonzc.github.io/2016/02/05/sonar-problem-list/"/>
    <id>http://bensonzc.github.io/2016/02/05/sonar-problem-list/</id>
    <published>2016-02-05T07:15:21.000Z</published>
    <updated>2016-02-29T08:00:42.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.sonarqube.org/" target="_blank" rel="external">Sonar</a>是一个开源平台，用于管理Java源代码的质量。本章知识介绍Sonar检验代码常出现的几个问题：</p>
<ul>
<li><p>安全-直接保存数组：<code>The user-supplied array &#39;xxxx&#39; is stored directly</code><br>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] getXXXXArray()&#123;</span><br><span class="line">	<span class="keyword">return</span> xxxxArray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXXXXArray</span><span class="params">(String[] xxxxArray)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.xxxxArray = xxxxArray;</span><br><span class="line">&#125;</span><br><span class="line">===&gt;</span><br><span class="line"><span class="keyword">public</span> String[] getXXXXArray()&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">null</span> != xxxxArray)&#123;</span><br><span class="line">		<span class="keyword">return</span> Arrays.copyOf(xxxxArray, xxxxArray.length);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXXXXArray</span><span class="params">(String[] xxxxArray)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">null</span> != xxxxArray)&#123;</span><br><span class="line">		<span class="keyword">this</span>.xxxxArray = Arrays.copyOf(xxxxArray, xxxxArray.length);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.xxxxArray = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>覆盖了equals也应该覆盖hashCode：<code>Definition of &#39;equals()&#39; without corresponding definition of &#39;hashCode()</code><br>如果覆盖了equals()方法的话，则必须覆盖hashCode()方法。Object类的equals()方法按照内存地址比较对象是否相等，因此如果object1.equals(object2)为true，表明object1变量和object2变量实际上引用同一个对象，那么object1和object2的哈希吗肯定也肯定也相同，也就是说object1.hashCode()==object2.hashCode()。<br>如果用户定义的类覆盖了Object类的equals()方法，但是没有覆盖Object类的hashCode()方法，就会导致当object1.equals(object2)为true时，object1和object2的哈希吗不一定一样。所以如果覆盖了equals()方法，也应该覆盖hashCode()方法，并且保证2个相等的object对象的哈希码也一样</p>
</li>
<li><p>返回之前不用的本地变量：<code>Consider simply returning the value vs storing it in local variable &#39;xxxx&#39;</code><br>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(String param)</span></span>&#123;</span><br><span class="line">	TestObject testObject = function(param);</span><br><span class="line">	<span class="keyword">return</span> testObject;</span><br><span class="line">&#125;</span><br><span class="line">===&gt;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(String param)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> function(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐藏属性：<code>&#39;****&#39; hides a field.</code><br>方法中声明的变量和成员属性名发生了重复</p>
</li>
<li><p>简化布尔表达式：<code>Expression can be simplified.</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(xxxx == <span class="keyword">false</span>)</span><br><span class="line">===&gt;</span><br><span class="line"><span class="keyword">if</span>(!xxxx)</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行比较时，比较常量应该放在左边</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(xxxx.equals(<span class="string">"0"</span>))&#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line">===&gt;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"0"</span>.equals(xxxx))&#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>待续……</p>
<h3 id="u4EE3_u7801_u89C4_u8303"><a href="#u4EE3_u7801_u89C4_u8303" class="headerlink" title="代码规范"></a>代码规范</h3><ul>
<li><p>避免在循环条件中使用复杂的表达式<br>循环条件被反复计算，程序运行时间会较长</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">===&gt;</span><br><span class="line"><span class="keyword">int</span> size = list.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br></pre></td></tr></table></figure>
</li>
<li><p>乘法和除法用移位操作代替<br>用移位操作替代乘法操作可以极大的提高性能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value = x * <span class="number">8</span>, value = x * <span class="number">2</span>;</span><br><span class="line">===&gt;</span><br><span class="line">value = x &lt;&lt; <span class="number">3</span>, value = x &lt;&lt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>尽量使用局部变量<br>调用方法时传递的参数和调用中创建的临时变量都保存在栈中，速度较快。其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。</p>
</li>
<li><p>用charAt()代替startsWith()<br>从性能角度来看，调用charAt()方法效率更高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(str.startsWith(<span class="string">"a"</span>))&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">===&gt;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">'a'</span> == str.charAt(<span class="number">0</span>))&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用’ ‘代替” “<br>如果字符串只有一个字符的话，使用’’代替””</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = str + <span class="string">"a"</span>;</span><br><span class="line">===&gt;</span><br><span class="line">String str = str + <span class="string">'a'</span>；</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在循环中调用synchronized()同步方法<br>synchronized方法需要消耗相当大的资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">		method();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">===&gt;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">			method();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将try/catch移除循环体<br>把try/catch块放入循环体内，会极大影响性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">===&gt;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.sonarqube.org/" target="_blank" rel="external">Sonar</a>是一个开源平台，用于管理Java源代码的质量。本章知识介绍Sonar检验代码常出现的几个问题：</p>
<ul>
<li>]]>
    </summary>
    
      <category term="code-style" scheme="http://bensonzc.github.io/tags/code-style/"/>
    
      <category term="java" scheme="http://bensonzc.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何部署https项目（tomcat）]]></title>
    <link href="http://bensonzc.github.io/2016/02/05/how-to-deploy-https-project/"/>
    <id>http://bensonzc.github.io/2016/02/05/how-to-deploy-https-project/</id>
    <published>2016-02-05T06:30:50.000Z</published>
    <updated>2016-02-05T07:14:51.000Z</updated>
    <content type="html"><![CDATA[<p>前段时间接了个外包项目，终端IOS要求请求走https。之前https都是某同事在倒腾，没有学习理解过，查了一些资料自己做点总结。</p>
<h2 id="1-__u4F55_u4E3Ahttps"><a href="#1-__u4F55_u4E3Ahttps" class="headerlink" title="1. 何为https"></a>1. 何为https</h2><p>高大上的理论解释网上一搜一打，就不做解释了。这里做最简单最通俗的解释：http的安全版本。通过在http下加入SSL层。一般意义上的https就是在服务器上有一个证书，服务端与客户端之间所有通讯都是加密的。客户端向服务端握个手，初始化下SSL层。这时候客户端和服务端就可以愉快的沟通了。这里主要介绍下复杂的SSL握手。</p>
<h3 id="SSL_u63E1_u624B_uFF08_u5355_u5411_u8BA4_u8BC1_uFF09"><a href="#SSL_u63E1_u624B_uFF08_u5355_u5411_u8BA4_u8BC1_uFF09" class="headerlink" title="SSL握手（单向认证）"></a>SSL握手（单向认证）</h3><ol>
<li>客户端（一般就是浏览器了）向服务端发送自己支持的加密规则。</li>
<li>服务端选择一组加密规则和HASH算法，以及服务端证书发送给浏览器。证书中包括网站地址，加密公钥，以及证书的颁发机构等信息。（SSL支持双向认证，服务端将证书发送给客户端，然后再将客户端的证书回送给服务端。但是实际应用中很多用户都没有自己的客户端证书，因此服务器也很少会要求客户端证书）</li>
<li>浏览器获取到服务端证书后要做一些操作：<ul>
<li>验证证书的合法性（颁发证书的机构是否合法等验证），如果证书合法，则浏览器会显示个小锁头，否则会给出证书不受信的提示。</li>
<li>如果证书受信任，或者用户接受了不受信任的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。</li>
<li>使用约定好的HASH算法计算握手消息，并使用刚生成的随机数对消息进行加密，最后将之前生成的所有信息发送给服务端。</li>
</ul>
</li>
<li>服务端收到浏览器发来的数据后做如下操作：<ul>
<li>使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手信息，并验证HASH是否与浏览器发来的是否一致。</li>
<li>使用密码加密一段握手消息，发送给浏览器。</li>
</ul>
</li>
<li>浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据都将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</li>
</ol>
<h3 id="u603B_u7ED3_u4E0B_u5C31_u662F_uFF1A"><a href="#u603B_u7ED3_u4E0B_u5C31_u662F_uFF1A" class="headerlink" title="总结下就是："></a>总结下就是：</h3><p>浏览器https请求连接，服务端将证书（里面有公钥）返回给浏览器，浏览器产生随机数（密钥）同时用公钥对随机数（密钥）加密。将加密后的随机数（密钥）发送给服务端。然后浏览器和服务端数据通信就用这个随机数（密钥）对称加密。</p>
<h2 id="2-__u5728tomcat_u670D_u52A1_u5668_u4E0A_u90E8_u7F72https"><a href="#2-__u5728tomcat_u670D_u52A1_u5668_u4E0A_u90E8_u7F72https" class="headerlink" title="2. 在tomcat服务器上部署https"></a>2. 在tomcat服务器上部署https</h2><h3 id="2-1__u751F_u6210_u5B89_u5168_u8BC1_u4E66"><a href="#2-1__u751F_u6210_u5B89_u5168_u8BC1_u4E66" class="headerlink" title="2.1 生成安全证书"></a>2.1 生成安全证书</h3><p>jdk为我们提供了个keytool.exe<br>生成证书的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -alias &#20135;&#29983;&#21035;&#21517; -keyalg &#25351;&#23450;&#23494;&#38053;&#31639;&#27861; -keystore &#23494;&#38053;&#36335;&#24452; -storepass &#23494;&#38053;&#30340;&#23494;&#30721; -keypass &#21035;&#21517;&#26465;&#30446;&#23494;&#30721;</span><br></pre></td></tr></table></figure></p>
<p>然后会出现让你输入以下信息：<br><img src="/2016/02/05/how-to-deploy-https-project/htdhp-1.jpg" alt=""></p>
<h3 id="2-2__u914D_u7F6Etomcat"><a href="#2-2__u914D_u7F6Etomcat" class="headerlink" title="2.2 配置tomcat"></a>2.2 配置tomcat</h3><p>tomcat目录下的conf/server.xml找到<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span><br><span class="line">&lt;Connector port="8443" protocol="org.apache.coyote.http11.Http11Protocol"</span><br><span class="line">           maxThreads="150" SSLEnabled="true" scheme="https" secure="true"</span><br><span class="line">           clientAuth="false" sslProtocol="TLS" /&gt;</span><br><span class="line">--&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>去掉注释，修改为<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">Connector</span> <span class="attribute">port</span>=<span class="value">"8443"</span> <span class="attribute">protocol</span>=<span class="value">"org.apache.coyote.http11.Http11Protocol"</span> </span><br><span class="line">		   <span class="attribute">maxThreads</span>=<span class="value">"150"</span> <span class="attribute">SSLEnabled</span>=<span class="value">"true"</span> <span class="attribute">scheme</span>=<span class="value">"https"</span> <span class="attribute">secure</span>=<span class="value">"true"</span></span><br><span class="line">		   <span class="attribute">clientAuth</span>=<span class="value">"false"</span> <span class="attribute">sslProtocol</span>=<span class="value">"TLS"</span> </span><br><span class="line">		   <span class="attribute">keystoreFile</span>=<span class="value">"keystore文件路径"</span> </span><br><span class="line">		   <span class="attribute">keystorePass</span>=<span class="value">"密码"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果让http自动跳转到https请求可以顺带修改配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redirectPort="8443"</span><br></pre></td></tr></table></figure></p>
<p>将http请求重定向到https请求上。</p>
<p>接下来就可以直接通过https访问了，实际项目运用过程中。可能更多的是通过授信的第三方购买证书。（搜了一下，感觉挺贵的。小几百一年）各位有兴趣可以购买一发，部署一发！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前段时间接了个外包项目，终端IOS要求请求走https。之前https都是某同事在倒腾，没有学习理解过，查了一些资料自己做点总结。</p>
<h2 id="1-__u4F55_u4E3Ahttps"><a href="#1-__u4F55_u4E3Ahttps" class]]>
    </summary>
    
      <category term="tomcat" scheme="http://bensonzc.github.io/tags/tomcat/"/>
    
      <category term="部署" scheme="http://bensonzc.github.io/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
</feed>
